<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>多进程 | 秋日诗意</title>
  <meta name="description" content="并发编程一 什么是进程进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。 举例（单核+多道，实现多个进程的并发执行）： 在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，　　 但同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？ 备一会课，再去跟女朋友聊聊天，再去打一会王者荣耀….这就保证了">
<meta property="og:type" content="article">
<meta property="og:title" content="多进程">
<meta property="og:url" content="https://david3901093.github.io/hexo.github.io/2024/04/16/python/day16/index.html">
<meta property="og:site_name" content="秋日诗意">
<meta property="og:description" content="并发编程一 什么是进程进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。 举例（单核+多道，实现多个进程的并发执行）： 在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，　　 但同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？ 备一会课，再去跟女朋友聊聊天，再去打一会王者荣耀….这就保证了">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-04-16T08:03:58.319Z">
<meta property="article:modified_time" content="2024-04-16T08:12:05.187Z">
<meta property="article:author" content="David Ge">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://david3901093.github.io/hexo.github.io/2024/04/16/python/day16/index.html">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/hexo.github.io/css/style.css">

  
  
  
  
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css">
  
<meta name="generator" content="Hexo 7.0.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/david3901093.github.io" target="_blank">
          <img class="img-circle img-rotate" src="/hexo.github.io/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">秋天的怀念</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java 程序员 &amp; Teacher</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> 中国江苏</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form" method="GET" action="https://www.baidu.com/s?">
	<div class="input-group">
    	<input name="wd" type="text" class="form-control search-form-input" placeholder="搜索" />
	    <span class="input-group-btn">
	    	<button type="submit" class=" btn btn-flat search-form-submit"><i class="icon icon-search"></i></button>
	    </span>
    </div>
</form>

</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">个性签名</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>常带一卷书生气，妙笔生花写传奇</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/hexo.github.io/categories/Python/">Python</a><span class="category-list-count">18</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo.github.io/categories/%E6%95%99%E4%B9%A6%E7%90%90%E8%AE%B0/">教书琐记</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo.github.io/categories/%E6%97%B6%E4%BA%8B%E7%83%AD%E7%82%B9/">时事热点</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/hexo.github.io/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/">生活点滴</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/Python/" rel="tag">Python</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E4%BA%B2%E6%83%85/" rel="tag">亲情</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/" rel="tag">四六级</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E5%A4%96%E5%A9%86/" rel="tag">外婆</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E6%AF%95%E4%B8%9A%E7%95%99%E8%A8%80/" rel="tag">毕业留言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" rel="tag">编程思维</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/hexo.github.io/tags/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/" rel="tag">英语作文</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/hexo.github.io/tags/Python/" style="font-size: 14px;">Python</a> <a href="/hexo.github.io/tags/%E4%BA%B2%E6%83%85/" style="font-size: 13px;">亲情</a> <a href="/hexo.github.io/tags/%E5%9B%9B%E5%85%AD%E7%BA%A7/" style="font-size: 13px;">四六级</a> <a href="/hexo.github.io/tags/%E5%A4%96%E5%A9%86/" style="font-size: 13px;">外婆</a> <a href="/hexo.github.io/tags/%E6%AF%95%E4%B8%9A%E7%95%99%E8%A8%80/" style="font-size: 13px;">毕业留言</a> <a href="/hexo.github.io/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 14px;">编程</a> <a href="/hexo.github.io/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" style="font-size: 13px;">编程思维</a> <a href="/hexo.github.io/tags/%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87/" style="font-size: 13px;">英语作文</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/hexo.github.io/archives/2024/04/">四月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo.github.io/archives/2024/03/">三月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo.github.io/archives/2024/02/">二月 2024</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo.github.io/archives/2024/01/">一月 2024</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/hexo.github.io/archives/2023/12/">十二月 2023</a><span class="archive-list-count">9</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/hexo.github.io/categories/Python/">Python</a>
              </p>
              <p class="item-title">
                <a href="/hexo.github.io/2024/04/26/python/day17/" class="title">多线程</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-26T08:21:08.031Z" itemprop="datePublished">2024-04-26</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/hexo.github.io/categories/%E6%95%99%E4%B9%A6%E7%90%90%E8%AE%B0/">教书琐记</a>
              </p>
              <p class="item-title">
                <a href="/hexo.github.io/2024/04/16/%E6%95%99%E5%AD%A6%E7%90%90%E8%AE%B0/%E2%80%9C%E5%AD%A6%E2%80%9D%E4%BB%A5%E8%87%B4%E2%80%9C%E7%94%A8%E2%80%9D%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E8%AF%BE%E7%A8%8B%E4%B8%8E%E7%BC%96%E7%A0%81%E6%80%9D%E7%BB%B4%E5%9F%B9%E5%85%BB%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8F%8D%E6%80%9D/" class="title">“学”以致“用”</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-16T08:12:26.927Z" itemprop="datePublished">2024-04-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/hexo.github.io/categories/Python/">Python</a>
              </p>
              <p class="item-title">
                <a href="/hexo.github.io/2024/04/16/python/day16/" class="title">多进程</a>
              </p>
              <p class="item-date">
                <time datetime="2024-04-16T08:03:58.319Z" itemprop="datePublished">2024-04-16</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/hexo.github.io/categories/Python/">Python</a>
              </p>
              <p class="item-title">
                <a href="/hexo.github.io/2024/03/19/python/day15/" class="title">网络通信</a>
              </p>
              <p class="item-date">
                <time datetime="2024-03-19T08:38:41.156Z" itemprop="datePublished">2024-03-19</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/hexo.github.io/categories/Python/">Python</a>
              </p>
              <p class="item-title">
                <a href="/hexo.github.io/2024/02/20/python/day13/" class="title">反射和内置函数</a>
              </p>
              <p class="item-date">
                <time datetime="2024-02-20T08:56:52.980Z" itemprop="datePublished">2024-02-20</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">文章目录</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">一 什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.2.</span> <span class="toc-text">二 进程与程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.0.3.</span> <span class="toc-text">三 并发与并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5and%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.0.4.</span> <span class="toc-text">四 同步\异步and阻塞\非阻塞（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.0.5.</span> <span class="toc-text">五 进程的创建（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.0.6.</span> <span class="toc-text">六 进程的终止（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.7.</span> <span class="toc-text">七 进程的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.0.8.</span> <span class="toc-text">八 进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-%E8%BF%9B%E7%A8%8B%E5%B9%B6%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.0.9.</span> <span class="toc-text">九 进程并发的实现（了解）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">多进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-multiprocessing%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.1.</span> <span class="toc-text">一 multiprocessing模块介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-Process%E7%B1%BB%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.2.</span> <span class="toc-text">二 Process类的介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-Process%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.0.3.</span> <span class="toc-text">三 Process类的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.0.4.</span> <span class="toc-text">四 守护进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5-%E9%94%81"><span class="toc-number">2.0.5.</span> <span class="toc-text">五 进程同步(锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E9%98%9F%E5%88%97%EF%BC%88%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">2.0.6.</span> <span class="toc-text">六 队列（推荐使用）</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-python/day16" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      多进程
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/hexo.github.io/2024/04/16/python/day16/" class="article-date">
	  <time datetime="2024-04-16T08:03:58.319Z" itemprop="datePublished">2024-04-16</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/hexo.github.io/categories/Python/">Python</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/hexo.github.io/tags/Python/" rel="tag">Python</a>, <a class="article-tag-link-link" href="/hexo.github.io/tags/%E7%BC%96%E7%A8%8B/" rel="tag">编程</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/hexo.github.io/2024/04/16/python/day16/#comments" class="article-comment-link">评论</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 12k(字)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 47(分)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h3 id="一-什么是进程"><a href="#一-什么是进程" class="headerlink" title="一 什么是进程"></a>一 什么是进程</h3><p>进程：正在进行的一个过程或者说一个任务。而负责执行任务则是cpu。</p>
<p>举例（单核+多道，实现多个进程的并发执行）：</p>
<p>在一个时间段内有很多任务要做：python备课的任务，写书的任务，交女朋友的任务，王者荣耀上分的任务，　　</p>
<p>但同一时刻只能做一个任务（cpu同一时间只能干一个活），如何才能玩出多个任务并发执行的效果？</p>
<p>备一会课，再去跟女朋友聊聊天，再去打一会王者荣耀….这就保证了每个任务都在进行中.</p>
<h3 id="二-进程与程序的区别"><a href="#二-进程与程序的区别" class="headerlink" title="二 进程与程序的区别"></a>二 进程与程序的区别</h3><p>程序仅仅只是一堆代码而已，而进程指的是程序的运行过程。</p>
<p>举例：</p>
<p>想象一位有一手好厨艺的计算机科学家正在为他的女儿烘制生日蛋糕。他有做生日蛋糕的食谱，厨房里有所需的原料:面粉、鸡蛋、韭菜，蒜泥等。</p>
<p>在这个比喻中：</p>
<p><strong>做蛋糕的食谱就是程序</strong>(即用适当形式描述的算法)</p>
<p><strong>计算机科学家就是处理器(cpu)</strong></p>
<p><strong>而做蛋糕的各种原料就是输入数据</strong>。</p>
<p><strong>进程就是厨师阅读食谱、取来各种原料以及烘制蛋糕等一系列动作的总和</strong>。</p>
<p>现在假设计算机科学家的儿子哭着跑了进来，说：嘿，爸爸，我的头被蜜蜂蛰了。</p>
<p>科学家想了想，处理儿子蛰伤的任务比给女儿做蛋糕的任务更重要，于是计算机科学家就记录下他照着食谱做到哪儿了(保存进程的当前状态)，然后拿出一本急救手册，按照其中的指示处理蛰伤。这里，我们看到处理机从一个进程(做蛋糕)切换到另一个高优先级的进程(实施医疗救治)，每个进程拥有各自的程序(食谱和急救手册)。当蜜蜂蛰伤处理完之后，这位计算机科学家又回来做蛋糕，从他 离开时的那一步继续做下去。</p>
<p><strong>需要强调的是：同一个程序执行两次，那也是两个进程，比如打开暴风影音，虽然都是同一个软件，但是一个可以播放苍井空，一个可以播放饭岛爱。</strong></p>
<h3 id="三-并发与并行"><a href="#三-并发与并行" class="headerlink" title="三 并发与并行"></a>三 并发与并行</h3><p>无论是并行还是并发，在用户看来都是’同时’运行的，不管是进程还是线程，都只是一个任务而已，真是干活的是cpu，cpu来做这些任务，而一个cpu同一时刻只能执行一个任务</p>
<p>一 并发：是伪并行，即看起来是同时运行。单个cpu+多道技术就可以实现并发，（并行也属于并发）</p>
<p>单cpu，多进程，并发举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个cpu，你同时谈了三个女朋友，每一个都可以是一个恋爱任务，你被这三个任务共享</span><br><span class="line">要玩出并发恋爱的效果。</span><br><span class="line">应该是你先跟女友<span class="number">1</span>去看电影，看了一会说：不好，我要拉肚子，然后跑去跟第二个女友吃饭，吃了一会说：那啥，我去趟洗手间，然后跑去跟女友<span class="number">3</span>开了个房</span><br></pre></td></tr></table></figure>

<p>二 并行：同时运行，只有具备多个cpu才能实现并行</p>
<p> 单核下，可以利用多道技术，多个核，每个核也都可以利用多道技术（<strong>多道技术是针对单核而言的</strong>）</p>
<p> 有四个核，六个任务，这样同一时间有四个任务被执行，假设分别被分配给了cpu1，cpu2，cpu3，cpu4，</p>
<p> 一旦任务1遇到I&#x2F;O就被迫中断执行，此时任务5就拿到cpu1的时间片去执行，这就是单核下的多道技术</p>
<p> 而一旦任务1的I&#x2F;O结束了，操作系统会重新调用它(<strong>需知进程的调度、分配给哪个cpu运行，由操作系统说了算</strong>)，可能被分配给四个cpu中的任意一个去执行</p>
<p>所有现代计算机经常会在同一时间做很多件事，一个用户的PC（无论是单cpu还是多cpu），都可以同时运行多个任务（一个任务可以理解为一个进程）。</p>
<p>启动一个进程来杀毒（360软件）</p>
<p>启动一个进程来看电影（暴风影音）</p>
<p>启动一个进程来聊天（腾讯QQ）</p>
<p>所有的这些进程都需被管理，于是一个支持多进程的多道程序系统是至关重要的</p>
<p>多道技术概念回顾：内存中同时存入多道（多个）程序，cpu从一个进程快速切换到另外一个，使每个进程各自运行几十或几百毫秒，这样，虽然在某一个瞬间，一个cpu只能执行一个任务，但在1秒内，cpu却可以运行多个进程，这就给人产生了并行的错觉，即伪并发，以此来区分多处理器操作系统的真正硬件并行（多个cpu共享同一个物理内存）</p>
<h3 id="四-同步-异步and阻塞-非阻塞（重点）"><a href="#四-同步-异步and阻塞-非阻塞（重点）" class="headerlink" title="四 同步\异步and阻塞\非阻塞（重点）"></a>四 同步\异步and阻塞\非阻塞（重点）</h3><p><strong>同步：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不会返回。按照这个定义，其实绝大多数函数都是同步调用。但是一般而言，我们在说同步、异步的时候，特指那些需要其他部件协作或者需要一定时间完成的任务。</span></span><br><span class="line"><span class="comment">#举例：</span></span><br><span class="line"><span class="comment">#1. multiprocessing.Pool下的apply #发起同步调用后，就在原地等着任务结束，根本不考虑任务是在计算还是在io阻塞，总之就是一股脑地等任务结束</span></span><br><span class="line"><span class="comment">#2. concurrent.futures.ProcessPoolExecutor().submit(func,).result()</span></span><br><span class="line"><span class="comment">#3. concurrent.futures.ThreadPoolExecutor().submit(func,).result()</span></span><br></pre></td></tr></table></figure>

<p><strong>异步：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#异步的概念和同步相对。当一个异步功能调用发出后，调用者不能立刻得到结果。当该异步功能完成后，通过状态、通知或回调来通知调用者。如果异步功能用状态来通知，那么调用者就需要每隔一定时间检查一次，效率就很低（有些初学多线程编程的人，总喜欢用一个循环去检查某个变量的值，这其实是一 种很严重的错误）。如果是使用通知的方式，效率则很高，因为异步功能几乎不需要做额外的操作。至于回调函数，其实和通知没太多区别。</span></span><br><span class="line"><span class="comment">#举例：</span></span><br><span class="line"><span class="comment">#1. multiprocessing.Pool().apply_async() #发起异步调用后，并不会等待任务结束才返回，相反，会立即获取一个临时结果（并不是最终的结果，可能是封装好的一个对象）。</span></span><br><span class="line"><span class="comment">#2. concurrent.futures.ProcessPoolExecutor(3).submit(func,)</span></span><br><span class="line"><span class="comment">#3. concurrent.futures.ThreadPoolExecutor(3).submit(func,)</span></span><br></pre></td></tr></table></figure>

<p><strong>阻塞：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#阻塞调用是指调用结果返回之前，当前线程会被挂起（如遇到IO操作）。函数只有在得到结果之后才会将阻塞的线程激活。有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回而已。</span></span><br><span class="line"><span class="comment">#举例：</span></span><br><span class="line"><span class="comment">#1. 同步调用：apply一个累计1亿次的任务，该调用会一直等待，直到任务返回结果为止，但并未阻塞住（即便是被抢走cpu的执行权限，那也是处于就绪态）;</span></span><br><span class="line"><span class="comment">#2. 阻塞调用：当socket工作在阻塞模式的时候，如果没有数据的情况下调用recv函数，则当前线程就会被挂起，直到有数据为止。</span></span><br></pre></td></tr></table></figure>

<p><strong>非阻塞：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前也会立刻返回，同时该函数不会阻塞当前线程。</span></span><br></pre></td></tr></table></figure>

<p><strong>小结：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1. 同步与异步针对的是函数/任务的调用方式：同步就是当一个进程发起一个函数（任务）调用的时候，一直等到函数（任务）完成，而进程继续处于激活状态。而异步情况下是当一个进程发起一个函数（任务）调用的时候，不会等函数返回，而是继续往下执行当，函数返回的时候通过状态、通知、事件等方式通知进程任务完成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2. 阻塞与非阻塞针对的是进程或线程：阻塞是当请求不能满足的时候就将进程挂起，而非阻塞则不会阻塞当前进程</span></span><br></pre></td></tr></table></figure>

<h3 id="五-进程的创建（了解）"><a href="#五-进程的创建（了解）" class="headerlink" title="五 进程的创建（了解）"></a>五 进程的创建（了解）</h3><p>但凡是硬件，都需要有操作系统去管理，只要有操作系统，就有进程的概念，就需要有创建进程的方式，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>而对于通用系统（跑很多应用程序），需要有系统运行过程中创建或撤销进程的能力，主要分为4种形式创建新的进程</p>
<ol>
<li><p>系统初始化（查看进程linux中用ps命令，windows中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web页面、新闻、打印）</p>
</li>
<li><p>一个进程在运行过程中开启了子进程（如nginx开启多进程，os.fork,subprocess.Popen等）</p>
</li>
<li><p>用户的交互式请求，而创建一个新进程（如用户双击暴风影音）</p>
</li>
<li><p>一个批处理作业的初始化（只在大型机的批处理系统中应用）</p>
</li>
</ol>
<p>无论哪一种，新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的：</p>
<ol>
<li><p>在UNIX中该系统调用是：fork，fork会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件（在shell解释器进程中，执行一个命令就会创建一个子进程）</p>
</li>
<li><p>在windows中该系统调用是：CreateProcess，CreateProcess既处理进程的创建，也负责把正确的程序装入新进程。</p>
</li>
</ol>
<p>　</p>
<p>关于创建的子进程，UNIX和windows</p>
<ol>
<li><p>相同的是：进程创建后，父进程和子进程有各自不同的地址空间（<strong>多道技术要求物理层面实现进程之间内存的隔离</strong>），任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</p>
</li>
<li><p>不同的是：在UNIX中，子进程的初始地址空间是父进程的一个副本，提示：子进程和父进程是可以有只读的共享内存区的。但是对于windows系统来说，从一开始父进程与子进程的地址空间就是不同的。</p>
</li>
</ol>
<h3 id="六-进程的终止（了解）"><a href="#六-进程的终止（了解）" class="headerlink" title="六 进程的终止（了解）"></a>六 进程的终止（了解）</h3><ol>
<li><p>正常退出（自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在linux中用exit，在windows中用ExitProcess）</p>
</li>
<li><p>出错退出（自愿，python a.py中a.py不存在）</p>
</li>
<li><p>严重错误（非自愿，执行非法指令，如引用不存在的内存，1&#x2F;0等，可以捕捉异常，try…except…）</p>
</li>
<li><p>被其他进程杀死（非自愿，如kill -9）</p>
</li>
</ol>
<h3 id="七-进程的层次结构"><a href="#七-进程的层次结构" class="headerlink" title="七 进程的层次结构"></a>七 进程的层次结构</h3><p>无论UNIX还是windows，进程只有一个父进程，不同的是：</p>
<ol>
<li><p>在UNIX中所有的进程，都是以init进程为根，组成树形结构。父子进程共同组成一个进程组，这样，当从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。</p>
</li>
<li><p>在windows中，没有进程层次的概念，所有的进程都是地位相同的，唯一类似于进程层次的暗示，是在创建进程时，父进程得到一个特别的令牌（<strong>称为句柄</strong>）,该句柄可以用来控制子进程，但是父进程有权把该句柄传给其他子进程，这样就没有层次了。</p>
</li>
</ol>
<h3 id="八-进程的状态"><a href="#八-进程的状态" class="headerlink" title="八 进程的状态"></a>八 进程的状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f access.log |grep &#x27;404&#x27;</span><br></pre></td></tr></table></figure>

<p>执行程序tail，开启一个子进程，执行程序grep，开启另外一个子进程，两个进程之间基于管道’|’通讯，将tail的结果作为grep的输入。</p>
<p>进程grep在等待输入（即I&#x2F;O）时的状态称为阻塞，此时grep命令都无法运行</p>
<p>其实在两种情况下会导致一个进程在逻辑上不能运行，</p>
<ol>
<li><p>进程挂起是自身原因，遇到I&#x2F;O阻塞，便要让出CPU让其他进程去执行，这样保证CPU一直在工作</p>
</li>
<li><p>与进程无关，是操作系统层面，可能会因为一个进程占用时间过多，或者优先级等原因，而调用其他的进程去使用CPU。</p>
</li>
</ol>
<p>因而一个进程由三种状态</p>
<h3 id="九-进程并发的实现（了解）"><a href="#九-进程并发的实现（了解）" class="headerlink" title="九 进程并发的实现（了解）"></a>九 进程并发的实现（了解）</h3><p>进程并发的实现在于，硬件中断一个正在运行的进程，把此时进程运行的所有状态保存下来，为此，操作系统维护一张表格，即进程表（process table），每个进程占用一个进程表项（这些表项也称为进程控制块）</p>
<h1 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h1><h3 id="一-multiprocessing模块介绍"><a href="#一-multiprocessing模块介绍" class="headerlink" title="一 multiprocessing模块介绍"></a>一 multiprocessing模块介绍</h3><p>python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing。 multiprocessing模块用来开启子进程，并在子进程中执行我们定制的任务（比如函数），该模块与多线程模块threading的编程接口类似。</p>
<p>multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。</p>
<p>需要再次强调的一点是：与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。</p>
<h3 id="二-Process类的介绍"><a href="#二-Process类的介绍" class="headerlink" title="二 Process类的介绍"></a>二 Process类的介绍</h3><p><strong>创建进程的类</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Process([group [, target [, name [, args [, kwargs]]]]])，由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span><br><span class="line"></span><br><span class="line">强调：</span><br><span class="line"><span class="number">1.</span> 需要使用关键字的方式来指定参数</span><br><span class="line"><span class="number">2.</span> args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> group参数未使用，值始终为<span class="literal">None</span></span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> target表示调用对象，即子进程要执行的任务</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> args表示调用对象的位置参数元组，args=(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;Gzl&#x27;</span>,)</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> kwargs表示调用对象的字典,kwargs=&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Gzl&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span> name为子进程的名称</span><br></pre></td></tr></table></figure>

<p><strong>方法介绍：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> p.start()：启动进程，并调用该子进程中的p.run() </span><br><span class="line"> <span class="number">2</span> p.run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  </span><br><span class="line"> <span class="number">3</span> </span><br><span class="line"> <span class="number">4</span> p.terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</span><br><span class="line"> <span class="number">5</span> p.is_alive():如果p仍然运行，返回<span class="literal">True</span></span><br><span class="line"> <span class="number">6</span> </span><br><span class="line"> <span class="number">7</span> p.join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</span><br></pre></td></tr></table></figure>

<p><strong>属性介绍：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> p.daemon：默认值为<span class="literal">False</span>，如果设为<span class="literal">True</span>，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为<span class="literal">True</span>后，p不能创建自己的新进程，必须在p.start()之前设置</span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="number">3</span> p.name:进程的名称</span><br><span class="line"><span class="number">4</span> </span><br><span class="line"><span class="number">5</span> p.pid：进程的pid</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> p.exitcode:进程在运行时为<span class="literal">None</span>、如果为–N，表示被信号N结束(了解即可)</span><br><span class="line"><span class="number">8</span> </span><br><span class="line"><span class="number">9</span> p.authkey:进程的身份验证键,默认是由os.urandom()随机生成的<span class="number">32</span>字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）</span><br></pre></td></tr></table></figure>

<h3 id="三-Process类的使用"><a href="#三-Process类的使用" class="headerlink" title="三 Process类的使用"></a>三 Process类的使用</h3><p><strong>注意：在windows中Process()必须放到# if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:下</strong></p>
<p>详细解释</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Since Windows has no fork, the multiprocessing module starts a new Python process <span class="keyword">and</span> imports the calling module. </span><br><span class="line">If Process() gets called upon <span class="keyword">import</span>, then this sets off an infinite succession of new processes (<span class="keyword">or</span> until your machine runs out of resources). </span><br><span class="line">This <span class="keyword">is</span> the reason <span class="keyword">for</span> hiding calls to Process() inside</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span></span><br><span class="line">since statements inside this <span class="keyword">if</span>-statement will <span class="keyword">not</span> get called upon <span class="keyword">import</span>.</span><br><span class="line">由于Windows没有fork，多处理模块启动一个新的Python进程并导入调用模块。 </span><br><span class="line">如果在导入时调用Process（），那么这将启动无限继承的新进程（或直到机器耗尽资源）。 </span><br><span class="line">这是隐藏对Process（）内部调用的原，使用<span class="keyword">if</span> __name__ == “__main __”，这个<span class="keyword">if</span>语句中的语句将不会在导入时被调用。</span><br></pre></td></tr></table></figure>

<p><strong>创建并开启子进程的两种方式</strong></p>
<p>方法一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125; is running&quot;</span>.<span class="built_in">format</span>(name=name))</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> is over&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 1 创建一个对象</span></span><br><span class="line">    p = Process(target=task, args=(<span class="string">&#x27;gzl&#x27;</span>,))</span><br><span class="line">    <span class="comment"># 容器类型哪怕里面只有1个元素 建议要用逗号隔开</span></span><br><span class="line">    <span class="comment"># 2 开启进程</span></span><br><span class="line">    p.start()  <span class="comment"># 告诉操作系统帮你创建一个进程  异步</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>方法二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开进程的方法二:</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcess</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;hello boy&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;goodbye&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess()</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程开始执行&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>进程直接的内存空间是隔离的</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">count =<span class="number">100</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子进程内部&quot;</span>,count)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=worker)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程&quot;</span>,count)</span><br></pre></td></tr></table></figure>

<p>练习1：把上周所学的socket通信变成并发的形式</p>
<p>server端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="comment"># 多进程版聊天室服务器</span></span><br><span class="line">server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 允许端口复用</span></span><br><span class="line">server.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">server.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>))</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">talk</span>(<span class="params">conn,client_addr</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmd = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            obj = subprocess.Popen(cmd.decode(<span class="string">&quot;utf-8&quot;</span>),</span><br><span class="line">                                   shell=<span class="literal">True</span>,</span><br><span class="line">                                   stdout=subprocess.PIPE, stderr=subprocess.PIPE</span><br><span class="line">                                   )</span><br><span class="line">            stdout_res = obj.stdout.read()</span><br><span class="line">            stderr_res = obj.stderr.read()</span><br><span class="line">            res_len = <span class="built_in">len</span>(stdout_res + stderr_res)</span><br><span class="line">            <span class="comment"># 封装头部</span></span><br><span class="line">            header = &#123;</span><br><span class="line">                <span class="string">&#x27;cmd&#x27;</span>: cmd.decode(<span class="string">&quot;GBK&quot;</span>),</span><br><span class="line">                <span class="string">&#x27;res_len&#x27;</span>: res_len,</span><br><span class="line">                <span class="string">&#x27;addr&#x27;</span>: <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment"># json 序列化</span></span><br><span class="line">            header_json = json.dumps(header)</span><br><span class="line">            <span class="built_in">print</span>(header_json)</span><br><span class="line">            json_bytes = header_json.encode(<span class="string">&quot;GBK&quot;</span>)</span><br><span class="line">            header_len = <span class="built_in">len</span>(json_bytes)</span><br><span class="line">            header_flag = struct.pack(<span class="string">&#x27;i&#x27;</span>, header_len)</span><br><span class="line">            <span class="comment"># 发送头部标志位</span></span><br><span class="line">            conn.send(header_flag)</span><br><span class="line">            <span class="comment"># 发送头部信息</span></span><br><span class="line">            conn.send(json_bytes)</span><br><span class="line">            <span class="comment"># 发送命令执行结果</span></span><br><span class="line">            conn.send(stdout_res + stderr_res)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="comment"># 一定要在main下启动线程，防止导入时执行开启进程，陷入无限循环</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 获取连接</span></span><br><span class="line">        conn, client_addr = server.accept()</span><br><span class="line">    <span class="comment"># 启动子进程</span></span><br><span class="line">        p = Process(target=talk, args=(conn, client_addr))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>多个client端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">client =socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8001</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&quot;请输入命令&gt;&gt;:&quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:<span class="keyword">continue</span></span><br><span class="line">    client.send(msg.encode(<span class="string">&quot;utf-8&quot;</span>))</span><br><span class="line">    <span class="comment"># 接收头部标志位</span></span><br><span class="line">    header_struct=client.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 解析头部长度</span></span><br><span class="line">    header_len=struct.unpack(<span class="string">&#x27;i&#x27;</span>,header_struct)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收头部信息</span></span><br><span class="line">    header_json=client.recv(header_len)</span><br><span class="line">    <span class="comment"># 解析头部</span></span><br><span class="line">    header=json.loads(header_json)</span><br><span class="line">    <span class="comment"># 获取数据长度</span></span><br><span class="line">    total_len=header[<span class="string">&#x27;res_len&#x27;</span>]</span><br><span class="line">    recv_len=<span class="number">0</span></span><br><span class="line">    <span class="comment"># 循环接收</span></span><br><span class="line">    <span class="keyword">while</span> total_len&gt;recv_len:</span><br><span class="line">        cmd_res = client.recv(<span class="number">1024</span>) <span class="comment"># 本次接收最大接收为1024Bytes</span></span><br><span class="line">        recv_len+=<span class="built_in">len</span>(cmd_res)</span><br><span class="line">        <span class="comment"># Windows平台GBK解码</span></span><br><span class="line">        <span class="built_in">print</span>(cmd_res.decode(<span class="string">&quot;GBK&quot;</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>这么实现有没有问题？？？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每来一个客户端，都在服务端开启一个进程，如果并发来一个万个客户端，要开启一万个进程吗，你自己尝试着在你自己的机器上开启一万个，<span class="number">10</span>万个进程试一试。</span><br><span class="line">解决方法：进程池</span><br></pre></td></tr></table></figure>

<p><em><strong>*Process对象的join方法*</strong></em></p>
<p>join：主进程等，等待子进程结束</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piao</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is working&#x27;</span> %self.name)</span><br><span class="line">        time.sleep(random.randrange(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is ending&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=Piao(<span class="string">&#x27;GZL&#x27;</span>)</span><br><span class="line">p.start()</span><br><span class="line">p.join(<span class="number">0.0001</span>) <span class="comment">#等待p停止,等0.0001秒就不再等了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>有了join，程序不就是串行了吗？？？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">name,num</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;name&#125;</span> 开始执行&quot;</span>)</span><br><span class="line">    time.sleep(num)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;任务 <span class="subst">&#123;name&#125;</span> 执行完成，耗时 <span class="subst">&#123;num&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    p_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=worker, args=(<span class="string">&quot;子进程&quot;</span>+<span class="built_in">str</span>(i),i))</span><br><span class="line">        p_list.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_list:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总时间消耗: <span class="subst">&#123;time.time() - start_time&#125;</span> 秒&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#有的同学会有疑问:既然join是等待进程结束,那么我像下面这样写,进程不就又变成串行的了吗?</span></span><br><span class="line"><span class="comment">#当然不是了,必须明确：p.join()是让谁等？</span></span><br><span class="line"><span class="comment">#很明显p.join()是让主线程等待p的结束，卡住的是主线程而绝非进程p，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#详细解析如下：</span></span><br><span class="line"><span class="comment">#进程只要start就会在开始运行了,所以p1-p4.start()时,系统中已经有四个并发的进程了</span></span><br><span class="line"><span class="comment">#而我们p1.join()是在等p1结束,没错p1只要不结束主线程就会一直卡在原地,这也是问题的关键</span></span><br><span class="line"><span class="comment">#join是让主线程等,而p1-p4仍然是并发执行的,p1.join的时候,其余p2,p3,p4仍然在运行,等#p1.join结束,可能p2,p3,p4早已经结束了,这样p2.join,p3.join.p4.join直接通过检测，无需等待</span></span><br><span class="line"><span class="comment"># 所以4个join花费的总时间仍然是耗费时间最长的那个进程运行的时间</span></span><br></pre></td></tr></table></figure>

<p><strong>Process对象的其他方法或属性（了解）</strong></p>
<p>terminate与is_alive</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进程对象的其他方法一:terminate,is_alive</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piao</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is processing&#x27;</span> %self.name)</span><br><span class="line">        time.sleep(random.randrange(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is ending&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1=Piao(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p1.terminate()<span class="comment">#关闭进程,不会立即关闭,所以is_alive立刻查看的结果可能还是存活</span></span><br><span class="line"><span class="built_in">print</span>(p1.is_alive()) <span class="comment">#结果为True</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p1.is_alive()) <span class="comment">#结果为False</span></span><br></pre></td></tr></table></figure>

<p>name与pid</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piao</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        <span class="comment"># self.name=name</span></span><br><span class="line">        <span class="comment"># super().__init__() #Process的__init__方法会执行self.name=Piao-1,</span></span><br><span class="line">        <span class="comment">#                    #所以加到这里,会覆盖我们的self.name=name</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#为我们开启的进程设置名字的做法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is processing&#x27;</span> %self.name)</span><br><span class="line">        time.sleep(random.randrange(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is ending&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line">p=Piao(<span class="string">&#x27;GZL&#x27;</span>)</span><br><span class="line">p.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;开始&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p.pid) <span class="comment">#查看pid</span></span><br></pre></td></tr></table></figure>

<p><strong>僵尸进程与孤儿进程（了解）</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">参考博客：http://www.cnblogs.com/Anker/p/<span class="number">3271773.</span>html</span><br><span class="line"></span><br><span class="line">一：僵尸进程（有害）</span><br><span class="line">　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。详解如下</span><br><span class="line"></span><br><span class="line">我们知道在unix/linux中，正常情况下子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束，如果子进程一结束就立刻回收其全部资源，那么在父进程内将无法获取子进程的状态信息。</span><br><span class="line"></span><br><span class="line">因此，UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：</span><br><span class="line"><span class="number">1</span>、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）</span><br><span class="line"><span class="number">2</span>、直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</span><br><span class="line"></span><br><span class="line">　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</span><br><span class="line"></span><br><span class="line">二：孤儿进程（无害）</span><br><span class="line"></span><br><span class="line">　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为<span class="number">1</span>)所收养，并由init进程对它们完成状态收集工作。</span><br><span class="line"></span><br><span class="line">　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</span><br><span class="line"></span><br><span class="line">我们来测试一下（创建完子进程后，主进程所在的这个脚本就退出了，当父进程先于子进程结束时，子进程会被init收养，成为孤儿进程，而非僵尸进程），文件内容</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">pid = os.getpid()</span><br><span class="line">ppid = os.getppid()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;I am father&#x27;</span>, <span class="string">&#x27;pid&#x27;</span>, pid, <span class="string">&#x27;ppid&#x27;</span>, ppid</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="comment">#执行pid=os.fork()则会生成一个子进程</span></span><br><span class="line"><span class="comment">#返回值pid有两种值：</span></span><br><span class="line"><span class="comment">#    如果返回的pid值为0，表示在子进程当中</span></span><br><span class="line"><span class="comment">#    如果返回的pid值&gt;0，表示在父进程当中</span></span><br><span class="line"><span class="keyword">if</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;father died..&#x27;</span></span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保证主线程退出完毕</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;im child&#x27;</span>, os.getpid(), os.getppid()</span><br><span class="line"></span><br><span class="line">执行文件，输出结果：</span><br><span class="line">im father pid <span class="number">32515</span> ppid <span class="number">32015</span></span><br><span class="line">father died..</span><br><span class="line">im child <span class="number">32516</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">看，子进程已经被pid为<span class="number">1</span>的init进程接收了，所以僵尸进程在这种情况下是不存在的，存在只有孤儿进程而已，孤儿进程声明周期结束自然会被init来销毁。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">三：僵尸进程危害场景：</span><br><span class="line"></span><br><span class="line">　　例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。</span><br><span class="line"></span><br><span class="line">四：测试</span><br><span class="line"><span class="comment">#1、产生僵尸进程的程序test.py内容如下</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子&#x27;</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>,os.getpid())</span><br><span class="line">    time.sleep(<span class="number">1000</span>)</span><br><span class="line">                                                                                              </span><br><span class="line"><span class="comment">#3、</span></span><br><span class="line">等待父进程正常结束后会调用wait／waitpid去回收僵尸进程</span><br><span class="line">但如果父进程是一个死循环，永远不会结束，那么该僵尸进程就会一直存在，僵尸进程过多，就是有害的</span><br><span class="line">解决方法一：杀死父进程</span><br><span class="line">解决方法二：对开启的子进程应该记得使用join，join会回收僵尸进程</span><br><span class="line">参考python2源码注释</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Process</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">join</span>(<span class="params">self, timeout=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Wait until child process terminates</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> self._parent_pid == os.getpid(), <span class="string">&#x27;can only join a child process&#x27;</span></span><br><span class="line">        <span class="keyword">assert</span> self._popen <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&#x27;can only join a started process&#x27;</span></span><br><span class="line">        res = self._popen.wait(timeout)</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            _current_process._children.discard(self)</span><br><span class="line"></span><br><span class="line">join方法中调用了wait，告诉系统释放僵尸进程。discard为从自己的children中剔除</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>思考：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join() <span class="comment"># 等待进程p结束后，join函数内部会发送系统调用wait，去告诉操作系统回收掉进程p的id号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.pid) <span class="comment">#？？？此时能否看到子进程p的id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>答案</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#答案：可以</span></span><br><span class="line"><span class="comment">#分析：</span></span><br><span class="line">p.join()是像操作系统发送请求，告知操作系统p的<span class="built_in">id</span>号不需要再占用了，回收就可以，</span><br><span class="line">此时在父进程内还可以看到p.pid,但此时的p.pid是一个无意义的<span class="built_in">id</span>号，因为操作系统已经将该编号回收</span><br><span class="line"></span><br><span class="line">打个比方：</span><br><span class="line">我党相当于操作系统，控制着整个中国的硬件，每个人相当于一个进程，每个人都需要跟我党申请一个身份证号</span><br><span class="line">该号码就相当于进程的pid，人死后应该到我党那里注销身份证号，p.join()就相当于要求我党回收身份证号，但p的家人（相当于主进程）</span><br><span class="line">仍然持有p的身份证，但此刻的身份证已经没有意义</span><br></pre></td></tr></table></figure>

<h3 id="四-守护进程"><a href="#四-守护进程" class="headerlink" title="四 守护进程"></a>四 守护进程</h3><p>主进程创建守护进程</p>
<p>其一：守护进程会在主进程代码执行结束后就终止</p>
<p>其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children</p>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Piao</span>(<span class="title class_ inherited__">Process</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is piaoing&#x27;</span> %self.name)</span><br><span class="line">        time.sleep(random.randrange(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is piao end&#x27;</span> %self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=Piao(<span class="string">&#x27;GZL&#x27;</span>)</span><br><span class="line">p.daemon=<span class="literal">True</span> <span class="comment">#一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line">p.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>迷惑人的例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主进程代码运行完毕,守护进程就会结束</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;end456&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1=Process(target=foo)</span><br><span class="line">p2=Process(target=bar)</span><br><span class="line"></span><br><span class="line">p1.daemon=<span class="literal">True</span></span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;main-------&quot;</span>) <span class="comment">#打印该行则主进程代码结束,则守护进程p1应该被终止,可能会有p1任务执行的打印信息123,因为主进程打印main----时,p1也执行了,但是随即被终止</span></span><br></pre></td></tr></table></figure>

<h3 id="五-进程同步-锁"><a href="#五-进程同步-锁" class="headerlink" title="五 进程同步(锁)"></a>五 进程同步(锁)</h3><p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,</p>
<p>而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理</p>
<p>part1：多个进程共享同一打印终端</p>
<p>并发运行,效率高,但竞争同一打印终端,带来了打印错乱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#并发运行,效率高,但竞争同一打印终端,带来了打印错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is done&#x27;</span> %os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work)</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>加锁：由并发变成了串行,牺牲了运行效率,但避免了竞争</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由并发变成了串行,牺牲了运行效率,但避免了竞争</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">lock</span>):</span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is done&#x27;</span> %os.getpid())</span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p=Process(target=work,args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>part2：多个进程共享同一文件</p>
<p>文件当数据库，模拟抢票</p>
<p>并发运行，效率高，但竞争写同一文件，数据写入错乱</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件db的内容为：&#123;&quot;count&quot;:1&#125;</span></span><br><span class="line"><span class="comment">#注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,random</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>():</span><br><span class="line">    dic=json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> %dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    dic=json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) <span class="comment">#模拟读数据的网络延迟</span></span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt;<span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>]-=<span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>) <span class="comment">#模拟写数据的网络延迟</span></span><br><span class="line">        json.dump(dic,<span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">lock</span>):</span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>): <span class="comment">#模拟并发100个客户端抢票</span></span><br><span class="line">        p=Process(target=task,args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>加锁：购票行为由并发变成了串行，牺牲了运行效率，但保证了数据安全</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time, random, json</span><br><span class="line"></span><br><span class="line"><span class="comment"># db.txt的数据为&#123;&quot;count&quot;:1&#125;</span></span><br><span class="line"><span class="comment"># 查询剩余票数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">search</span>():</span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> % dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 购票操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get</span>():</span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        json.dump(dic, <span class="built_in">open</span>(<span class="string">&#x27;db.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票失败\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务执行函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">task</span>(<span class="params">lock</span>):</span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建进程锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建并启动多个进程来执行任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span></span><br><span class="line">虽然可以用文件共享数据实现进程间通信，但问题是：</span><br><span class="line"><span class="number">1.</span>效率低（共享数据基于文件，而文件是硬盘上的数据）</span><br><span class="line"><span class="number">2.</span>需要自己加锁处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span></span><br><span class="line"><span class="number">1</span> 队列和管道都是将数据存放于内存中</span><br><span class="line"><span class="number">2</span> 队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，</span><br><span class="line">我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span><br></pre></td></tr></table></figure>

<h3 id="六-队列（推荐使用）"><a href="#六-队列（推荐使用）" class="headerlink" title="六 队列（推荐使用）"></a>六 队列（推荐使用）</h3><p>进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的</p>
<p><strong>创建队列的类（底层就是以管道和锁定的方式实现）</strong>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。</span><br></pre></td></tr></table></figure>

<p><strong>参数介绍：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 maxsize是队列中允许最大项数，省略则无大小限制。</span><br></pre></td></tr></table></figure>

<p><strong>方法介绍：</strong></p>
<p>主要方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为<span class="literal">True</span>（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为<span class="literal">False</span>，但该Queue已满，会立即抛出Queue.Full异常。</span><br><span class="line"><span class="number">2</span> q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为<span class="literal">True</span>（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为<span class="literal">False</span>，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.</span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"><span class="number">4</span> q.get_nowait():同q.get(<span class="literal">False</span>)</span><br><span class="line"><span class="number">5</span> q.put_nowait():同q.put(<span class="literal">False</span>)</span><br><span class="line"><span class="number">6</span> </span><br><span class="line"><span class="number">7</span> q.empty():调用此方法时q为空则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中又加入了项目。</span><br><span class="line"><span class="number">8</span> q.full()：调用此方法时q已满则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中的项目被取走。</span><br><span class="line"><span class="number">9</span> q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</span><br></pre></td></tr></table></figure>

<p>其他方法(了解)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞</span><br><span class="line"><span class="number">2</span> q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中的队列不会导致get()方法返回错误。</span><br><span class="line"><span class="number">3</span> q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可以禁止这种行为</span><br></pre></td></tr></table></figure>

<p><strong>应用：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">multiprocessing模块支持进程间通信的两种主要形式:管道和队列</span></span><br><span class="line"><span class="string">都是基于消息传递实现的,但是队列接口</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">q=Queue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#put ,get ,put_nowait,get_nowait,full,empty</span></span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full()) <span class="comment">#满了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.empty()) <span class="comment">#空了</span></span><br></pre></td></tr></table></figure>

<p><strong>生产者消费者模型</strong></p>
<p><em>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。</em></p>
<p><strong>为什么要使用生产者和消费者模式</strong></p>
<p><em>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。</em></p>
<p><strong>什么是生产者消费者模式</strong></p>
<p><em>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</em></p>
<p><em>基于队列实现生产者消费者模型</em></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[45m%s 吃 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">&#x27;包子%s&#x27;</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[44m%s 生产了 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:<span class="comment"># 生产者-消费者模型</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random, os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q, name</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125;吃了&#123;item&#125;&quot;</span>.<span class="built_in">format</span>(name=name, item=item))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q, name</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        result = <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>生产了包子<span class="subst">&#123;i&#125;</span>号&quot;</span></span><br><span class="line">        q.put(result)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125;生产了&#123;result&#125;&quot;</span>.<span class="built_in">format</span>(name=name, result=result))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line">    p1 = Process(target=consumer, args=(q, <span class="string">&quot;小明&quot;</span>))</span><br><span class="line">    p2 = Process(target=consumer, args=(q, <span class="string">&quot;小红&quot;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&quot;老板&quot;</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有进程都结束了&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>生产者消费者模型总结</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生产者消费者模型总结</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#程序中有两类角色</span></span><br><span class="line">        一类负责生产数据（生产者）</span><br><span class="line">        一类负责处理数据（消费者）</span><br><span class="line"></span><br><span class="line">    <span class="comment">#引入生产者消费者模型为了解决的问题是：</span></span><br><span class="line">        平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度</span><br><span class="line"></span><br><span class="line">    <span class="comment">#如何实现：</span></span><br><span class="line">        生产者&lt;--&gt;队列&lt;——&gt;消费者</span><br><span class="line">    <span class="comment">#生产者消费者模型实现类程序的解耦合</span></span><br></pre></td></tr></table></figure>

<p>此时的问题是主进程永远不会结束，原因是：生产者p在生产完后就结束了，但是消费者c在取空了q之后，则一直处于死循环中且卡在q.get()这一步。</p>
<p>解决方式无非是让生产者在生产完毕后，往队列中再发一个结束信号，这样消费者在接收到结束信号后就可以break出死循环</p>
<p>生产者在生产完毕后发送结束信号None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[45m%s 吃 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">&#x27;包子%s&#x27;</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[44m%s 生产了 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>注意：结束信号None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号</p>
<p>主进程在生产者生产完毕后发送结束信号None</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[45m%s 吃 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">&#x27;包子%s&#x27;</span> %i</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[44m%s 生产了 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>但上述解决方式，在有多个生产者和多个消费者时，我们则需要用一个很low的方式去解决</p>
<p>有几个消费者就需要发送几次结束信号：相当low</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Queue</span><br><span class="line"><span class="keyword">import</span> time,random,os</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res=q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:<span class="keyword">break</span> <span class="comment">#收到结束信号则结束</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[45m%s 吃 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">name,q</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        res=<span class="string">&#x27;%s%s&#x27;</span> %(name,i)</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[44m%s 生产了 %s\033[0m&#x27;</span> %(os.getpid(),res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q=Queue()</span><br><span class="line">    <span class="comment">#生产者们:即厨师们</span></span><br><span class="line">    p1=Process(target=producer,args=(<span class="string">&#x27;包子&#x27;</span>,q))</span><br><span class="line">    p2=Process(target=producer,args=(<span class="string">&#x27;骨头&#x27;</span>,q))</span><br><span class="line">    p3=Process(target=producer,args=(<span class="string">&#x27;泔水&#x27;</span>,q))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#消费者们:即吃货们</span></span><br><span class="line">    c1=Process(target=consumer,args=(q,))</span><br><span class="line">    c2=Process(target=consumer,args=(q,))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#开始</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    c1.start()</span><br><span class="line"></span><br><span class="line">    p1.join() <span class="comment">#必须保证生产者全部生产完毕,才应该发送结束信号</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#有几个消费者就应该发送几次结束信号None</span></span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment">#发送结束信号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>其实我们的思路无非是发送结束信号而已，有另外一种队列提供了这种机制</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#JoinableQueue([maxsize])：这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#参数介绍：</span></span><br><span class="line">    maxsize是队列中允许最大项数，省略则无大小限制。    </span><br><span class="line">　 <span class="comment">#方法介绍：</span></span><br><span class="line">    JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：</span><br><span class="line">    q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常</span><br><span class="line">    q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止</span><br><span class="line"><span class="comment"># 生产者-消费者模型</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">q, name</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        item = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;name&#125;吃了&#123;item&#125;&quot;</span>.<span class="built_in">format</span>(name=name, item=item))</span><br><span class="line">        <span class="keyword">if</span> q.empty():  <span class="comment"># 如果队列已经空了，发送完成信号</span></span><br><span class="line">           q.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">q, name</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        result = <span class="string">f&quot;<span class="subst">&#123;name&#125;</span>生产了包子<span class="subst">&#123;i&#125;</span>号&quot;</span></span><br><span class="line">        q.put(result)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line">    p1 = Process(target=consumer, args=(q, <span class="string">&quot;小明&quot;</span>))</span><br><span class="line">    p2 = Process(target=consumer, args=(q, <span class="string">&quot;小红&quot;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&quot;老板&quot;</span>))</span><br><span class="line">    p1.daemon=<span class="literal">True</span></span><br><span class="line">    p2.daemon=<span class="literal">True</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p3.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;所有进程都结束了&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#主进程等---&gt;p1等----&gt;p2,p3</span></span><br><span class="line">    <span class="comment">#p1结束了,证明p2,p3肯定全都收完了p1到队列的数据</span></span><br><span class="line">    <span class="comment">#因而p1,p2也没有存在的价值了,应该随着主进程的结束而结束,所以设置成守护进程</span></span><br><span class="line">    <span class="comment"># 厨师下班了，还在店里吃什么</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://david3901093.github.io/hexo.github.io/2024/04/16/python/day16/" title="多进程" target="_blank" rel="external">https://david3901093.github.io/hexo.github.io/2024/04/16/python/day16/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/david3901093.github.io" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/hexo.github.io/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/david3901093.github.io" target="_blank"><span class="text-dark">秋天的怀念</span><small class="ml-1x">Java 程序员 &amp; Teacher</small></a></h3>
        <div>会写点小文章的程序员。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
           
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/hexo.github.io/2024/04/16/%E6%95%99%E5%AD%A6%E7%90%90%E8%AE%B0/%E2%80%9C%E5%AD%A6%E2%80%9D%E4%BB%A5%E8%87%B4%E2%80%9C%E7%94%A8%E2%80%9D%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E8%AF%BE%E7%A8%8B%E4%B8%8E%E7%BC%96%E7%A0%81%E6%80%9D%E7%BB%B4%E5%9F%B9%E5%85%BB%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8F%8D%E6%80%9D/" title="“学”以致“用”"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/hexo.github.io/2024/03/19/python/day15/" title="网络通信"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn   collapsed  " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button">    <span>[&nbsp;</span><span>文章目录</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="qq,wechat,qqzone,weibo" data-mobile-sites="wechat,weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/hexo.github.io/js/plugin.min.js"></script>


<script src="/hexo.github.io/js/application.js"></script>



    <script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:david3901093.github.io/hexo.github.io ' + keyword;
        return false;
    });
})(jQuery);
</script>




   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"> -->
  <script src="//cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '7b983dbe11c92bd3e3c6',
    clientSecret: '4e6afef671c6cf51be01b5fe66e0c2f1e0c07a62',
    repo: 'hexo.github.io',
    owner: 'David3901093',
    admin: ['David3901093'],
    id: md5(location.pathname),
    distractionFreeMode: true,
    language: 'zh-CN',
    enableHotKey: 'true',
    proxy:"https://proxy-gitalk-api.netlify.app/github_access_token"

  })
  gitalk.render('comments')
  </script>
      







</body>
</html>